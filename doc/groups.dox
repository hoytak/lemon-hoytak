/* -*- C++ -*-
 *
 * This file is a part of LEMON, a generic C++ optimization library
 *
 * Copyright (C) 2003-2008
 * Egervary Jeno Kombinatorikus Optimalizalasi Kutatocsoport
 * (Egervary Research Group on Combinatorial Optimization, EGRES).
 *
 * Permission to use, modify and distribute this software is granted
 * provided that this copyright notice appears in all copies. For
 * precise terms see the accompanying LICENSE file.
 *
 * This software is provided "AS IS" with no warranty of any kind,
 * express or implied, and with no claim as to its suitability for any
 * purpose.
 *
 */

/**
@defgroup datas Data Structures
This group describes the several data structures implemented in LEMON.
*/

/**
@defgroup graphs Graph Structures
@ingroup datas
\brief Graph structures implemented in LEMON.

The implementation of combinatorial algorithms heavily relies on 
efficient graph implementations. LEMON offers data structures which are 
planned to be easily used in an experimental phase of implementation studies, 
and thereafter the program code can be made efficient by small modifications. 

The most efficient implementation of diverse applications require the
usage of different physical graph implementations. These differences
appear in the size of graph we require to handle, memory or time usage
limitations or in the set of operations through which the graph can be
accessed.  LEMON provides several physical graph structures to meet
the diverging requirements of the possible users.  In order to save on
running time or on memory usage, some structures may fail to provide
some graph features like arc/edge or node deletion.

Alteration of standard containers need a very limited number of 
operations, these together satisfy the everyday requirements. 
In the case of graph structures, different operations are needed which do 
not alter the physical graph, but gives another view. If some nodes or 
arcs have to be hidden or the reverse oriented graph have to be used, then
this is the case. It also may happen that in a flow implementation 
the residual graph can be accessed by another algorithm, or a node-set 
is to be shrunk for another algorithm. 
LEMON also provides a variety of graphs for these requirements called 
\ref graph_adaptors "graph adaptors". Adaptors cannot be used alone but only 
in conjunction with other graph representations. 

You are free to use the graph structure that fit your requirements
the best, most graph algorithms and auxiliary data structures can be used
with any graph structures. 
*/

/**
@defgroup semi_adaptors Semi-Adaptor Classes for Graphs
@ingroup graphs
\brief Graph types between real graphs and graph adaptors.

This group describes some graph types between real graphs and graph adaptors.
These classes wrap graphs to give new functionality as the adaptors do it. 
On the other hand they are not light-weight structures as the adaptors.
*/

/**
@defgroup maps Maps 
@ingroup datas
\brief Map structures implemented in LEMON.

This group describes the map structures implemented in LEMON.

LEMON provides several special purpose maps that e.g. combine
new maps from existing ones.
*/

/**
@defgroup graph_maps Graph Maps 
@ingroup maps
\brief Special graph-related maps.

This group describes maps that are specifically designed to assign
values to the nodes and arcs of graphs.
*/


/**
\defgroup map_adaptors Map Adaptors
\ingroup maps
\brief Tools to create new maps from existing ones

This group describes map adaptors that are used to create "implicit"
maps from other maps.

Most of them are \ref lemon::concepts::ReadMap "read-only maps".
They can make arithmetic and logical operations between one or two maps
(negation, shifting, addition, multiplication, logical 'and', 'or',
'not' etc.) or e.g. convert a map to another one of different Value type.

The typical usage of this classes is passing implicit maps to
algorithms.  If a function type algorithm is called then the function
type map adaptors can be used comfortable. For example let's see the
usage of map adaptors with the \c digraphToEps() function.
\code
  Color nodeColor(int deg) {
    if (deg >= 2) {
      return Color(0.5, 0.0, 0.5);
    } else if (deg == 1) {
      return Color(1.0, 0.5, 1.0);
    } else {
      return Color(0.0, 0.0, 0.0);
    }
  }
  
  Digraph::NodeMap<int> degree_map(graph);
  
  digraphToEps(graph, "graph.eps")
    .coords(coords).scaleToA4().undirected()
    .nodeColors(composeMap(functorToMap(nodeColor), degree_map))
    .run();
\endcode 
The \c functorToMap() function makes an \c int to \c Color map from the
\e nodeColor() function. The \c composeMap() compose the \e degree_map
and the previously created map. The composed map is a proper function to
get the color of each node.

The usage with class type algorithms is little bit harder. In this
case the function type map adaptors can not be used, because the
function map adaptors give back temporary objects.
\code
  Digraph graph;

  typedef Digraph::ArcMap<double> DoubleArcMap;
  DoubleArcMap length(graph);
  DoubleArcMap speed(graph);

  typedef DivMap<DoubleArcMap, DoubleArcMap> TimeMap;
  TimeMap time(length, speed);
  
  Dijkstra<Digraph, TimeMap> dijkstra(graph, time);
  dijkstra.run(source, target);
\endcode
We have a length map and a maximum speed map on the arcs of a digraph.
The minimum time to pass the arc can be calculated as the division of
the two maps which can be done implicitly with the \c DivMap template
class. We use the implicit minimum time map as the length map of the
\c Dijkstra algorithm.
*/

/**
@defgroup matrices Matrices 
@ingroup datas
\brief Two dimensional data storages implemented in LEMON.

This group describes two dimensional data storages implemented in LEMON.
*/

/**
@defgroup paths Path Structures
@ingroup datas
\brief Path structures implemented in LEMON.

This group describes the path structures implemented in LEMON.

LEMON provides flexible data structures to work with paths.
All of them have similar interfaces and they can be copied easily with
assignment operators and copy constructors. This makes it easy and
efficient to have e.g. the Dijkstra algorithm to store its result in
any kind of path structure.

\sa lemon::concepts::Path

*/

/**
@defgroup auxdat Auxiliary Data Structures
@ingroup datas
\brief Auxiliary data structures implemented in LEMON.

This group describes some data structures implemented in LEMON in
order to make it easier to implement combinatorial algorithms.
*/


/**
@defgroup algs Algorithms
\brief This group describes the several algorithms
implemented in LEMON.

This group describes the several algorithms
implemented in LEMON.
*/

/**
@defgroup search Graph Search
@ingroup algs
\brief Common graph search algorithms.

This group describes the common graph search algorithms like 
Breadth-first search (Bfs) and Depth-first search (Dfs).
*/

/**
@defgroup shortest_path Shortest Path algorithms
@ingroup algs
\brief Algorithms for finding shortest paths.

This group describes the algorithms for finding shortest paths in graphs.
*/

/** 
@defgroup max_flow Maximum Flow algorithms 
@ingroup algs 
\brief Algorithms for finding maximum flows.

This group describes the algorithms for finding maximum flows and
feasible circulations.

The maximum flow problem is to find a flow between a single source and
a single target that is maximum. Formally, there is a \f$G=(V,A)\f$
directed graph, an \f$c_a:A\rightarrow\mathbf{R}^+_0\f$ capacity
function and given \f$s, t \in V\f$ source and target node. The
maximum flow is the \f$f_a\f$ solution of the next optimization problem:

\f[ 0 \le f_a \le c_a \f]
\f[ \sum_{v\in\delta^{-}(u)}f_{vu}=\sum_{v\in\delta^{+}(u)}f_{uv} \qquad \forall u \in V \setminus \{s,t\}\f]
\f[ \max \sum_{v\in\delta^{+}(s)}f_{uv} - \sum_{v\in\delta^{-}(s)}f_{vu}\f]

LEMON contains several algorithms for solving maximum flow problems:
- \ref lemon::EdmondsKarp "Edmonds-Karp" 
- \ref lemon::Preflow "Goldberg's Preflow algorithm"
- \ref lemon::DinitzSleatorTarjan "Dinitz's blocking flow algorithm with dynamic trees"
- \ref lemon::GoldbergTarjan "Preflow algorithm with dynamic trees"

In most cases the \ref lemon::Preflow "Preflow" algorithm provides the
fastest method to compute the maximum flow. All impelementations
provides functions to query the minimum cut, which is the dual linear
programming problem of the maximum flow.

*/

/**
@defgroup min_cost_flow Minimum Cost Flow algorithms
@ingroup algs

\brief Algorithms for finding minimum cost flows and circulations.

This group describes the algorithms for finding minimum cost flows and
circulations.  
*/

/**
@defgroup min_cut Minimum Cut algorithms 
@ingroup algs 

\brief Algorithms for finding minimum cut in graphs.

This group describes the algorithms for finding minimum cut in graphs.

The minimum cut problem is to find a non-empty and non-complete
\f$X\f$ subset of the vertices with minimum overall capacity on
outgoing arcs. Formally, there is \f$G=(V,A)\f$ directed graph, an
\f$c_a:A\rightarrow\mathbf{R}^+_0\f$ capacity function. The minimum
cut is the \f$X\f$ solution of the next optimization problem:

\f[ \min_{X \subset V, X\not\in \{\emptyset, V\}}\sum_{uv\in A, u\in X, v\not\in X}c_{uv}\f]

LEMON contains several algorithms related to minimum cut problems:

- \ref lemon::HaoOrlin "Hao-Orlin algorithm" to calculate minimum cut
  in directed graphs  
- \ref lemon::NagamochiIbaraki "Nagamochi-Ibaraki algorithm" to
  calculate minimum cut in undirected graphs
- \ref lemon::GomoryHuTree "Gomory-Hu tree computation" to calculate all
  pairs minimum cut in undirected graphs

If you want to find minimum cut just between two distinict nodes,
please see the \ref max_flow "Maximum Flow page".

*/

/**
@defgroup graph_prop Connectivity and other graph properties
@ingroup algs
\brief Algorithms for discovering the graph properties

This group describes the algorithms for discovering the graph properties
like connectivity, bipartiteness, euler property, simplicity etc.

\image html edge_biconnected_components.png
\image latex edge_biconnected_components.eps "bi-edge-connected components" width=\textwidth
*/

/**
@defgroup planar Planarity embedding and drawing
@ingroup algs
\brief Algorithms for planarity checking, embedding and drawing

This group describes the algorithms for planarity checking, embedding and drawing.

\image html planar.png
\image latex planar.eps "Plane graph" width=\textwidth
*/

/**
@defgroup matching Matching algorithms 
@ingroup algs
\brief Algorithms for finding matchings in graphs and bipartite graphs.

This group contains algorithm objects and functions to calculate
matchings in graphs and bipartite graphs. The general matching problem is
finding a subset of the arcs which does not shares common endpoints.
 
There are several different algorithms for calculate matchings in
graphs.  The matching problems in bipartite graphs are generally
easier than in general graphs. The goal of the matching optimization
can be the finding maximum cardinality, maximum weight or minimum cost
matching. The search can be constrained to find perfect or
maximum cardinality matching.

Lemon contains the next algorithms:
- \ref lemon::MaxBipartiteMatching "MaxBipartiteMatching" Hopcroft-Karp 
  augmenting path algorithm for calculate maximum cardinality matching in 
  bipartite graphs
- \ref lemon::PrBipartiteMatching "PrBipartiteMatching" Push-Relabel 
  algorithm for calculate maximum cardinality matching in bipartite graphs 
- \ref lemon::MaxWeightedBipartiteMatching "MaxWeightedBipartiteMatching" 
  Successive shortest path algorithm for calculate maximum weighted matching 
  and maximum weighted bipartite matching in bipartite graph
- \ref lemon::MinCostMaxBipartiteMatching "MinCostMaxBipartiteMatching" 
  Successive shortest path algorithm for calculate minimum cost maximum 
  matching in bipartite graph
- \ref lemon::MaxMatching "MaxMatching" Edmond's blossom shrinking algorithm
  for calculate maximum cardinality matching in general graph
- \ref lemon::MaxWeightedMatching "MaxWeightedMatching" Edmond's blossom
  shrinking algorithm for calculate maximum weighted matching in general
  graph
- \ref lemon::MaxWeightedPerfectMatching "MaxWeightedPerfectMatching"
  Edmond's blossom shrinking algorithm for calculate maximum weighted
  perfect matching in general graph

\image html bipartite_matching.png
\image latex bipartite_matching.eps "Bipartite Matching" width=\textwidth

*/

/**
@defgroup spantree Minimum Spanning Tree algorithms
@ingroup algs
\brief Algorithms for finding a minimum cost spanning tree in a graph.

This group describes the algorithms for finding a minimum cost spanning
tree in a graph
*/


/**
@defgroup auxalg Auxiliary algorithms
@ingroup algs
\brief Auxiliary algorithms implemented in LEMON.

This group describes some algorithms implemented in LEMON
in order to make it easier to implement complex algorithms.
*/

/**
@defgroup approx Approximation algorithms
\brief Approximation algorithms.

This group describes the approximation and heuristic algorithms
implemented in LEMON.
*/

/**
@defgroup gen_opt_group General Optimization Tools
\brief This group describes some general optimization frameworks
implemented in LEMON.

This group describes some general optimization frameworks
implemented in LEMON.

*/

/**
@defgroup lp_group Lp and Mip solvers
@ingroup gen_opt_group
\brief Lp and Mip solver interfaces for LEMON.

This group describes Lp and Mip solver interfaces for LEMON. The
various LP solvers could be used in the same manner with this
interface.

*/

/** 
@defgroup lp_utils Tools for Lp and Mip solvers 
@ingroup lp_group
\brief Helper tools to the Lp and Mip solvers.

This group adds some helper tools to general optimization framework
implemented in LEMON.
*/

/**
@defgroup metah Metaheuristics
@ingroup gen_opt_group
\brief Metaheuristics for LEMON library.

This group describes some metaheuristic optimization tools.
*/

/**
@defgroup utils Tools and Utilities 
\brief Tools and utilities for programming in LEMON

Tools and utilities for programming in LEMON.
*/

/**
@defgroup gutils Basic Graph Utilities
@ingroup utils
\brief Simple basic graph utilities.

This group describes some simple basic graph utilities.
*/

/**
@defgroup misc Miscellaneous Tools
@ingroup utils
\brief Tools for development, debugging and testing.

This group describes several useful tools for development,
debugging and testing.
*/

/**
@defgroup timecount Time measuring and Counting
@ingroup misc
\brief Simple tools for measuring the performance of algorithms.

This group describes simple tools for measuring the performance
of algorithms.
*/

/**
@defgroup graphbits Tools for Graph Implementation
@ingroup utils
\brief Tools to make it easier to create graphs.

This group describes the tools that makes it easier to create graphs and
the maps that dynamically update with the graph changes.
*/

/**
@defgroup exceptions Exceptions
@ingroup utils
\brief Exceptions defined in LEMON.

This group describes the exceptions defined in LEMON.
*/

/**
@defgroup io_group Input-Output
\brief Graph Input-Output methods

This group describes the tools for importing and exporting graphs 
and graph related data. Now it supports the LEMON format, the
\c DIMACS format and the encapsulated postscript (EPS) format.
*/

/**
@defgroup lemon_io Lemon Input-Output
@ingroup io_group
\brief Reading and writing LEMON format

This group describes methods for reading and writing LEMON format. 
You can find more about this format on the \ref graph-io-page "Graph Input-Output"
tutorial pages.
*/

/**
@defgroup section_io Section readers and writers
@ingroup lemon_io
\brief Section readers and writers for LEMON Input-Output.

This group describes section reader and writer classes that can be 
attached to \ref LemonReader and \ref LemonWriter.
*/

/**
@defgroup item_io Item readers and writers
@ingroup lemon_io
\brief Item readers and writers for LEMON Input-Output.

This group describes reader and writer classes for various data types
(e.g. map or attribute values). These classes can be attached to
\ref LemonReader and \ref LemonWriter.
*/

/**
@defgroup eps_io Postscript exporting
@ingroup io_group
\brief General \c EPS drawer and graph exporter

This group describes general \c EPS drawing methods and special
graph exporting tools. 
*/


/**
@defgroup concept Concepts
\brief Skeleton classes and concept checking classes

This group describes the data/algorithm skeletons and concept checking
classes implemented in LEMON.

The purpose of the classes in this group is fourfold.
 
- These classes contain the documentations of the concepts. In order
  to avoid document multiplications, an implementation of a concept
  simply refers to the corresponding concept class.

- These classes declare every functions, <tt>typedef</tt>s etc. an
  implementation of the concepts should provide, however completely
  without implementations and real data structures behind the
  interface. On the other hand they should provide nothing else. All
  the algorithms working on a data structure meeting a certain concept
  should compile with these classes. (Though it will not run properly,
  of course.) In this way it is easily to check if an algorithm
  doesn't use any extra feature of a certain implementation.

- The concept descriptor classes also provide a <em>checker class</em>
  that makes it possible to check whether a certain implementation of a
  concept indeed provides all the required features.

- Finally, They can serve as a skeleton of a new implementation of a concept.

*/


/**
@defgroup graph_concepts Graph Structure Concepts
@ingroup concept
\brief Skeleton and concept checking classes for graph structures

This group describes the skeletons and concept checking classes of LEMON's
graph structures and helper classes used to implement these.
*/

/* --- Unused group
@defgroup experimental Experimental Structures and Algorithms
This group describes some Experimental structures and algorithms.
The stuff here is subject to change.
*/

/**
\anchor demoprograms

@defgroup demos Demo programs

Some demo programs are listed here. Their full source codes can be found in
the \c demo subdirectory of the source tree.

It order to compile them, use <tt>--enable-demo</tt> configure option when
build the library.
*/

/**
@defgroup tools Standalone utility applications

Some utility applications are listed here. 

The standard compilation procedure (<tt>./configure;make</tt>) will compile
them, as well. 
*/

